### 면접 질문: "Dependency Injection(DI)에 대해 설명해 주세요."

#### 답변 예시
Dependency Injection(DI)은 객체 지향 프로그래밍에서 사용되는 디자인 패턴으로, 객체의 의존성(즉, 다른 객체와의 관계)을 외부에서 주입하는 방법입니다. 이는 객체 간의 결합도를 낮추고, 코드의 재사용성, 테스트 용이성, 유지보수성을 높이는 데 도움을 줍니다.

#### DI의 핵심 개념
1. **의존성 분리**: DI는 객체가 직접 의존 객체를 생성하는 대신, 외부(예: 프레임워크 또는 컨테이너)에서 필요한 의존성을 주입받습니다.
2. **결합도 감소**: 객체는 필요한 의존성만을 제공받기 때문에, 다른 구성 요소와의 결합도가 감소합니다. 이로 인해 개별 구성 요소를 쉽게 교체하거나 수정할 수 있습니다.
3. **코드 재사용 및 테스트 용이성**: 의존성이 외부에서 주입되므로, 같은 객체를 다양한 시나리오에 재사용할 수 있으며, 단위 테스트가 용이해집니다.

#### DI의 구현 방법
1. **생성자 주입**: 객체를 생성할 때 생성자를 통해 의존성을 주입합니다.
2. **세터 주입**: 객체 생성 후 세터 메소드(setter)를 통해 의존성을 주입합니다.
3. **필드 주입**: 필드(멤버 변수)에 직접 의존성을 주입합니다. 이 방법은 테스트와 코드 정리에 있어 단점이 있을 수 있습니다.

#### DI의 장점
- **유지보수성 향상**: 코드의 변경이 필요할 때 의존성을 쉽게 교체할 수 있습니다.
- **단위 테스트 용이성**: 실제 객체 대신 모의 객체(Mock Object)를 주입하여 단위 테스트를 용이하게 할 수 있습니다.
- **코드의 가독성과 관리 용이성**: 의존성 관리가 중앙화되어 코드의 가독성과 관리가 용이합니다.

### 결론
DI는 소프트웨어 아키텍처의 유연성을 크게 향상시키는 효과적인 기법입니다. 객체 지향 설계 원칙 중 하나인 '의존성 역전 원칙(Dependency Inversion Principle)'의 구현 방법으로, 소프트웨어의 모듈성과 테스트 용이성을 개선하는 데 기여합니다.

### Dependency Injection (DI)에 대한 설명

#### DI의 핵심 개념
- **의존성(종속성) 이해**: 객체가 올바르게 기능하기 위해 필요한 다른 객체(의존성)가 있습니다. 예를 들어, 'OrderService' 클래스가 'PaymentService' 클래스에 의존할 수 있습니다.

- **외부 주입**: 객체가 자신의 의존성을 직접 생성하는 대신, 외부(컨테이너 또는 프레임워크)에서 필요한 의존성을 주입합니다.

- **결합도 감소**: 객체는 필요한 의존성만을 제공받으므로, 다른 객체와의 결합도가 감소합니다. 이는 시스템의 유연성과 확장성을 향상시킵니다.

#### DI의 구현 방법
1. **생성자 주입(Constructor Injection)**: 의존성을 객체 생성자를 통해 주입합니다. 이 방법은 의존성이 불변하고, 필수적일 때 적합합니다.

2. **세터 주입(Setter Injection)**: 세터 메소드를 통해 의존성을 주입합니다. 이 방법은 선택적이거나 변경 가능한 의존성에 적합합니다.

3. **필드 주입(Field Injection)**: 리플렉션을 통해 클래스의 필드에 직접 의존성을 주입합니다. 간단하지만, 테스트와 유지보수 측면에서는 권장되지 않습니다.

#### DI의 장점
1. **유지보수 용이**: 객체가 직접 의존성을 관리하지 않기 때문에, 의존성 변경이 쉬워집니다.

2. **테스트 용이**: 실제 객체 대신 모의 객체(Mock) 또는 스텁(Stub)을 주입하여 테스트를 용이하게 합니다.

3. **재사용성 및 확장성 향상**: 의존성이 외부에서 제공되므로, 다양한 상황에서 객체를 재사용할 수 있습니다.

4. **객체의 단일 책임 원칙 강화**: 객체는 생성이 아닌 로직에 집중할 수 있어, 단일 책임 원칙(Single Responsibility Principle)을 더 잘 준수할 수 있습니다.

#### DI의 단점
1. **학습 곡선**: DI를 처음 접하는 개발자에게는 이해하기 어려울 수 있습니다.

2. **초기 구성 복잡성**: DI를 위한 초기 구성(예: 스프링 프레임워크 설정)이 복잡할 수 있습니다.

3. **런타임 오류 가능성**: 컴파일 타임이 아닌 런타임에 의존성 관련 오류가 발생할 수 있습니다.

